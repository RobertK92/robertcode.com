<!doctype html>
<html>
<head>
<meta charset="utf-8">
<link href="https://fonts.googleapis.com/css?family=Muli" rel="stylesheet">
<link rel="stylesheet" type="text/css" href="darkstyle.css">
<link rel="stylesheet" href="styles/agate.css">

<script src="highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<script src="jquery.js"></script> 
	<script> 
	$(function(){
	  $("#sideMenu").load("sideMenu.html"); 
	});
</script>

	   
<title>Robertkn - Procedural Generation</title>
</head>

<div class="wrapper">	
	<img id="backgroundImage" src="images/bg.jpg">
	
	<section>
	<div id="sideMenu">	
	</div>
	
	<div class="content"> 
		<div class="projectContent">
			<h1>Procedural Generation</h1> 
			<a class="repoLink" href="https://github.com/RobertK92/Procedural2D" target="_blank"> Github Repository </a>
			<br>
			<hr>
			<p><i>For this project I use MonoGame C# and my homemade framework library called "MonoGameToolkit" which is a generic framework I use in all my monogame projects. <a class="URL" href="mgtk.html"> Click here</a> for more info about the  MonoGameToolkit. </i></p>
			<hr>
			<p> With this project, I aim to create a procedurally generated world with an gigantic amount of tiles and objects while still running at a high framerate and acceptable memory usage (60+ FPS, < 1GB RAM). </p>
			<p> In the video below you can see a 10k x 10k generated world (a total of 100 million 16x16 tiles). <br> The world will automatically create and destroy chunks based on the players location in the chunk grid.</p>
			<video class="projectVideo" width="1100" controls>
				<source src="videos/vidProcedural1.mp4" type="video/mp4">
			</video>
			<p> Every gray square in the video is a chunk. <br> 1 chunk consists of 256 tiles (16x16) baked together into a single texture on runtime.</p>
			<p> The code below gives some insight in how I generate  chunk. </p>
			
			
			<button class="showCodeButton" onClick="OnShowCodeButtonPressed('showChunkCodeText', 'chunkCode')">
				<p class="showCodeText" id="showChunkCodeText">Show Code</p>
			</button>
			
			<pre class="code" id="chunkCode"><code>
/* Create tiles */
for (int y = 0; y < Config.ChunkHeight; y++)
{
	for (int x = 0; x < Config.ChunkWidth; x++)
	{
		TileId mask = chunk.Data.Tiles[x, y];
		Color[,] newColors = new Color[TileWidth, TileHeight];
		bool newColorsCreated = false;

		foreach (TileId value in Enum.GetValues(mask.GetType()))
		{
			if ((mask & value) == value)
			{
				TileId id = value;
				Tile tile = _tiles[id];
				Texture2D tex = Content.Load<Texture2D>(tile.Texture);

				if (_usedTiles.ContainsKey(mask))
				{
					Color[,] usedColors = _usedTiles[mask];
					for (int cy = 0; cy < usedColors.GetLength(1); cy++)
					{
						for (int cx = 0; cx < usedColors.GetLength(0); cx++)
						{
							_chunkColors[(x * TileWidth) + cx, (y * TileHeight) + cy] = usedColors[cx, cy];
						}
					}
				}
				else
				{
					Color[] texColors = new Color[TileWidth * TileHeight];
					tex.GetData(0, tile.SourceRect, texColors, 0, (tile.SourceRect.Width * tile.SourceRect.Height));

					for (int ty = 0; ty < tile.SourceRect.Height; ty++)
					{
						for (int tx = 0; tx < tile.SourceRect.Width; tx++)
						{
							Color c = texColors[ty * tile.SourceRect.Height + tx];
							if (c == Color.Magenta || c.A == 0)
								continue;

							int cx = (x * TileWidth) + tx;
							int cy = (y * TileHeight) + ty;
							Color current = _chunkColors[cx, cy];

							/* Blend semi-transparant color with the color underneath */
							if(current != Color.Transparent && c.A < 255)
							{
								float amount = (c.A / 255.0f);
								byte r = (byte)((c.R * amount) + current.R * (1 - amount));
								byte g = (byte)((c.G * amount) + current.G * (1 - amount));
								byte b = (byte)((c.B * amount) + current.B * (1 - amount));
								c = new Color(r, g, b, 255);
							}
							_chunkColors[cx, cy] = c;
							newColors[tx, ty] = c;
						}
					}
					newColorsCreated = true;
				}
			}
		}
		if(newColorsCreated)
			_usedTiles.Add(mask, newColors);
	}
}

Texture2D texture = new Texture2D(GraphicsDevice, _chunkColors.GetLength(0), _chunkColors.GetLength(1), false, SurfaceFormat.Color);
texture.SetData(_chunkColors.To1DArray());</code></pre>
			
			<p>The world generator also allows for non-tile based objects too be created and destroyed automatically using the same chunk-based culling system. <br> The video below shows how every tree has 1 collider for the physics and 1 trigger collider to detect if the player is behind it. It will then fade out the leaves so the player can be seen at all times.</p>
			
			<video class="projectVideo" width="1100" controls>
				<source src="videos/vidProceduralPhysics.mp4" type="video/mp4">
			</video>
			
			<p>The world contains a number of regions, at the moment, only the "Grasslands" region is implemented. <br> Other regions will be: Icy Peaks, Snow Forest, Grizzly Hills, Grasslands, Jungle, Desert and The Lavalands. Where the north is cold and icy and the tempature rises and environment changes the further south you go. The type of enemies you encounter will also depend on the region you are in.</p>
			<p>The code below shows how the tiles are generated for the Grasslands.</p>
			
			<button class="showCodeButton" onClick="OnShowCodeButtonPressed('showGrasslandsCodeText', 'grasslandsCode')">
				<p class="showCodeText" id="showGrasslandsCodeText">Show Code</p>
			</button>
			
			<pre class="code" id="grasslandsCode"><code>
public override void GenerateTileData(ref TileId[,] tiles, ref List<WorldObjectDef> objects, int x, int y, int tx, int ty)
{
	TileLocation current = new TileLocation(new Point(x, y), new Point(tx, ty));

	GenerateGround(x, y, tx, ty, ref tiles);
	GenerateSmallPlants(x, y, tx, ty, ref tiles);
	GenerateTrees(x, y, tx, ty, ref objects);
	GenerateMunshrooms(x, y, tx, ty, ref objects, tiles);

}

private void GenerateGround(int x, int y, int tx, int ty, ref TileId[,] tiles)
{
	World.Perlin.OctaveCount = World.Config.Grasslands.GroundNoiseOctaves;
	World.Perlin.Frequency = World.Config.Grasslands.GroundNoiseFrequency;
	World.Perlin.Persistence = World.Config.Grasslands.GroundNoisePersistence;
	World.Perlin.Lacunarity = World.Config.Grasslands.GroundNoiseLacunarity;
	double nx = (double)tx / (World.Config.ChunkWidth);
	double ny = (double)ty / (World.Config.ChunkHeight);

	double noise = World.Perlin.GetValue(x + nx, y + ny, 0.0f);

	if (noise > World.Config.Grasslands.GrassFrequency)
	{
		GenerateTile(ref tiles, x, y, tx, ty, TileId.River1, GrassCorners);
	}
	else 
	{
		GenerateTile(ref tiles, x, y, tx, ty, TileId.Grass1, GrassCorners);
	}
}
			</code></pre>
			
			<p>I use perlin noise for most of the generations (e.g. for organic-looking rivers and lakes) <br> In order to easily configure the world generator, I deserialize data from an XML.</p>
			
			
			<button class="showCodeButton" onClick="OnShowCodeButtonPressed('worldXmlCodeText', 'worldXmlCode')">
				<p class="showCodeText" id="showWorldXmlCodeText">Show Code</p>
			</button>
			
			<pre><code class="code" id="worldXmlCode">
&lt;World&gt; 
  &lt;ShowWholeWorld&gt;false&lt;/ShowWholeWorld&gt;
  &lt;ChunkWidth> 16 &lt;/ChunkWidth&gt;
  &lt;ChunkHeight> 16 &lt;/ChunkHeight&gt;
  &lt;RenderRadiusInChunks&gt; 6 &lt;/RenderRadiusInChunks&gt;
  &lt;WorldObjectFadingEnabled&gt; true &lt;/WorldObjectFadingEnabled&gt;
  &lt;WorldObjectFadingSpeed&gt; 0.5 &lt;/WorldObjectFadingSpeed&gt;
  &lt;WorldObjectFadingOpacity&gt; 0.75 &lt;/WorldObjectFadingOpacity&gt;
  &lt;UpdatePlayerChunkEveryXSeconds&gt; 0.5 &lt;/UpdatePlayerChunkEveryXSeconds&gt;

  &lt;Grasslands&gt;
    &lt;GrassFrequency&gt; 2.0 &lt;/GrassFrequency&gt;
    &lt;GroundNoiseOctaves&gt; 2 &lt;/GroundNoiseOctaves&gt;
    &lt;GroundNoiseFrequency&gt; 0.5 &lt;/GroundNoiseFrequency&gt;
    &lt;GroundNoisePersistence&gt; 9.0 &lt;/GroundNoisePersistence&gt;
    &lt;GroundNoiseLacunarity&gt; 2.0 &lt;/GroundNoiseLacunarity&gt;

    &lt;Flowers1SpawnChance&gt; 2.0 &lt;/Flowers1SpawnChance&gt;
    &lt;Flowers2SpawnChance&gt; 1.0 &lt;/Flowers2SpawnChance&gt;

    &lt;TreeNoiseOctaves&gt; 2 &lt;/TreeNoiseOctaves&gt;
    &lt;TreeNoiseFrequency&gt; 0.5 &lt;/TreeNoiseFrequency&gt;
    &lt;TreeNoisePersistence&gt; 1.0 &lt;/TreeNoisePersistence&gt;
    &lt;TreeNoiseLacunarity&gt; 2.0 &lt;/TreeNoiseLacunarity&gt;
    &lt;TreeMinSpacing&gt; 2 &lt;/TreeMinSpacing&gt;

    &lt;MunshroomFrequency&gt; 0.1 &lt;/MunshroomFrequency&gt;
    &lt;MunshroomNoiseOctaves&gt; 1 &lt;/MunshroomNoiseOctaves&gt;
    &lt;MunshroomsNoiseFrequency&gt; 2.0 &lt;/MunshroomsNoiseFrequency&gt;
    &lt;MunshroomsNoisePersistence&gt; 1.0 &lt;/MunshroomsNoisePersistence&gt;
    &lt;MunshroomsNoiseLacunarity&gt; 2.0 &lt;/MunshroomsNoiseLacunarity&gt;

  &lt;/Grasslands&gt;


&lt;/World&gt;
			</code></pre>
			
			<p> This also allows for hot-reloading of the world. So I can change a value and regenerate the world without having to restart the application.</p>
			
			<br>
		</div>
	</div>
	</section>
</div>


<body>

<script>
	function OnShowCodeButtonPressed(buttonTextId, codeId)
	{
		ToggleElement(codeId);	
		var code = document.getElementById(codeId);
		var buttonText = document.getElementById(buttonTextId);
		
		if(code.style.display == "none")
		{
			buttonText.innerHTML = "Show Code";
		}
		else if(code.style.display == "block")
		{
			buttonText.innerHTML = "Hide Code";
		}
	}
	
	function ToggleElement(id) 
	{
		var element = document.getElementById(id);
		var state = element.style.display;

		if(state == "block") 
		{
			element.style.display = "none";
		}
		else 
		{
			element.style.display = "block";
		}
	}
</script>
</body>
</html>
